<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<!--
  Hamigaki.Coroutine Library Document Source

  Copyright Takeshi Mouri 2008.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)

  See http://hamigaki.sourceforge.jp/libs/coroutine for library home page.
-->
<section id="coroutine.tutorial">
  <title>チュートリアル</title>
  <using-namespace name="hamigaki::coroutines"/>
  <section id="coroutine.tutorial.coroutines">
    <title>コルーチン</title>
    <para>コルーチンとは、処理を中断したり、再開することのできるサブルーチンの変種である。</para>
    <para>Hamigaki.Coroutineはコルーチンを作成するためのクラステンプレート<classname alt="coroutineN">coroutine</classname>を提供している。ここでは<classname alt="coroutineN">coroutine</classname>を用いて掛け算九九の答えを表示するプログラムを考える。</para>
    <programlisting><![CDATA[#include <hamigaki/coroutine/coroutine.hpp>]]></programlisting>
    <para>これは<classname alt="coroutineN">coroutine</classname>を使用するために必要である。</para>
    <programlisting><![CDATA[namespace coro = hamigaki::coroutines;

typedef coro::coroutine<int()> coroutine_type;
]]></programlisting>
    <para><classname alt="coroutineN">coroutine</classname>は名前空間<code>hamigaki::coroutines</code>で定義される。唯一のテンプレート引数はコルーチンの型を指定するためのものである。ここでは<code>int</code>型の戻り値を持ち、引数を持たないコルーチンを使用する。</para>
    <programlisting><![CDATA[int kuku_body(coroutine_type::self& self)
{
    for (int i = 1; i <= 9; ++i)
        for (int j = 1; j <= 9; ++j)
            self.yield(i*j);

    self.exit();
}
]]></programlisting>
    <para>関数<code>kuku_body()</code>はコルーチンの本体である。この関数の型は<classname alt="coroutineN">coroutine</classname>のテンプレート引数に指定したものに<code>coroutine_type::self&amp;</code>型の引数を追加したものになる。この追加された引数はコルーチンの制御を行うために使用される。</para>
    <para>メンバ関数<code>yield()</code>はコルーチンの呼び出し側に制御を戻し、引数をコルーチンの計算結果として返す関数である。</para>
    <para>また、メンバ関数<code>exit()</code>はコルーチンの実行を中断し、呼び出し側に制御を戻す関数である。</para>
    <programlisting><![CDATA[#include <iostream>

int main()
{
    try
    {
        coroutine_type kuku(kuku_body);
        while (true)
            std::cout << kuku() << std::endl;
    }
    catch (const coro::coroutine_exited&)
    {
    }
}
]]></programlisting>
    <para><classname alt="coroutineN">coroutine</classname>のコンストラクタの引数にはコルーチンの本体を指定する。</para>
    <para>作成された<classname alt="coroutineN">coroutine</classname>は関数オブジェクトとして機能する。コルーチンを呼び出すと、制御がコルーチン本体へと移る。コルーチン側は<code>yield()</code>が呼ばれるか、<code>return</code>されるまで実行され、その結果が呼び出し側に返される。再びコルーチンを呼び出すと、前回<code>yield()</code>を呼んだ箇所から実行が再開される。</para>
    <para>メンバ関数<code>exit()</code>が呼ぶか、コルーチンから<code>return</code>すると、コルーチンは終了する。終了したコルーチンを呼び出すと、例外<classname>coroutine_exited</classname>が発生する。コルーチンはその性質上、呼び出すまで終了したかどうか分からないので、この例外を捕捉することで終了を検知する。</para>
    <para>別の方法として、コルーチンの呼び出し時に<code>std::nothrow</code>を引数として指定することもできる。この場合、戻り値が<code>boost::optional</code>になり、終了を検知した場合は空となる。</para>
    <programlisting><![CDATA[#include <iostream>

int main()
{
    coroutine_type kuku(kuku_body);
    while (boost::optional<int> next = kuku(std::nothrow))
        std::cout << *next << std::endl;
}
]]></programlisting>
    <para>完全なプログラムは以下のようになる。</para>
    <programlisting><![CDATA[#include <hamigaki/coroutine/coroutine.hpp>

namespace coro = hamigaki::coroutines;

typedef coro::coroutine<int()> coroutine_type;

int kuku_body(coroutine_type::self& self)
{
    for (int i = 1; i <= 9; ++i)
        for (int j = 1; j <= 9; ++j)
            self.yield(i*j);

    self.exit();
}


#include <iostream>

int main()
{
    try
    {
        coroutine_type kuku(kuku_body);
        while (true)
            std::cout << kuku() << std::endl;
    }
    catch (const coro::coroutine_exited&)
    {
    }
}
]]></programlisting>
  </section>
</section>
